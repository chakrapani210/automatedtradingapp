import pandas as pd
import numpy as np
from typing import Any, Dict, Optional
from .strategy_interface import TradingStrategy
import yfinance as yf
from datetime import datetime, timedelta

class LongTermValueStrategy(TradingStrategy):
    """
    A long-term strategy combining fundamental value screens with technical indicators
    for entry and exit timing.

    Indicators Used:
    - SMAs (50, 100, 200): For trend direction and Golden/Death Cross signals.
    - Aroon Indicator (25 periods): To measure trend strength and identify emerging trends.
    - On-Balance Volume (OBV): To confirm price trends with volume momentum.

    Strategy Logic:
    1.  **Fundamental Screen**: Only considers trades for companies that meet basic
        value criteria (e.g., P/E, P/B ratios).
    2.  **Entry Signal (BUY)**: A "Golden Cross" (SMA50 crosses above SMA200) is the
        primary entry trigger. This signal is confirmed by:
        - A strong uptrend indicated by the Aroon Indicator (Aroon Up > 70).
        - Positive volume pressure, confirmed by a rising OBV (OBV > OBV's moving average).
    3.  **Exit Signal (SELL)**: A "Death Cross" (SMA50 crosses below SMA200) triggers
        a position exit.
    """

    FUND_REFRESH_DAYS = 30

    def __init__(self):
        self._fund_cache: Dict[str, Dict[str, Any]] = {}
        self._fund_timestamp: Dict[str, datetime] = {}

    # -------- Indicator Calculations --------

    def _calculate_smas(self, df: pd.DataFrame) -> pd.DataFrame:
        """Calculates 50, 100, and 200-period Simple Moving Averages."""
        df['sma_50'] = df['Close'].rolling(window=50).mean()
        df['sma_100'] = df['Close'].rolling(window=100).mean()
        df['sma_200'] = df['Close'].rolling(window=200).mean()
        return df

    def _calculate_aroon(self, df: pd.DataFrame, period: int = 25) -> pd.DataFrame:
        """
        Calculates the Aroon Indicator (Aroon Up and Aroon Down).
        Own implementation as a suitable library is not available.
        """
        high_roll = df['High'].rolling(period + 1)
        low_roll = df['Low'].rolling(period + 1)

        # Get the number of periods since the max high and min low
        df['aroon_up_days'] = high_roll.apply(lambda x: float(np.argmax(x)), raw=True)
        df['aroon_down_days'] = low_roll.apply(lambda x: float(np.argmin(x)), raw=True)

        # Scale to 0-100
        df['aroon_up'] = ((period - df['aroon_up_days']) / period) * 100
        df['aroon_down'] = ((period - df['aroon_down_days']) / period) * 100
        
        # Aroon Oscillator
        df['aroon_osc'] = df['aroon_up'] - df['aroon_down']
        return df

    def _calculate_obv(self, df: pd.DataFrame) -> pd.DataFrame:
        """Calculates On-Balance Volume."""
        price_change = df['Close'].diff()
        volume = df['Volume']
        
        obv = (np.sign(price_change) * volume).fillna(0).cumsum()
        df['obv'] = obv
        df['obv_sma_20'] = df['obv'].rolling(window=20).mean()
        return df

    # -------- Fundamentals --------

    def _fetch_fundamentals(self, ticker: str) -> Dict[str, Any]:
        try:
            stock = yf.Ticker(ticker)
            info = getattr(stock, 'info', {}) or {}
            return {
                'pe_ratio': info.get('forwardPE', float('inf')),
                'pb_ratio': info.get('priceToBook', float('inf')),
            }
        except Exception:
            return {}

    def get_fundamental_data(self, ticker: str) -> Dict[str, Any]:
        now = datetime.utcnow()
        ts = self._fund_timestamp.get(ticker)
        if ts is None or (now - ts) > timedelta(days=self.FUND_REFRESH_DAYS):
            data = self._fetch_fundamentals(ticker)
            self._fund_cache[ticker] = data
            self._fund_timestamp[ticker] = now
        return self._fund_cache.get(ticker, {})

    # -------- Core Signal Logic --------

    def generate_signals(self, data: pd.DataFrame, config: Any) -> pd.Series:
        df_in = next(iter(data.values())) if isinstance(data, dict) else data
        ticker = getattr(df_in, 'attrs', {}).get('ticker', 'UNKNOWN')
        df = df_in.copy()

        if df.empty or len(df) < 200:  # Need enough data for 200-day SMA
            return pd.Series(0, index=df.index)

        # 1. Calculate all technical indicators
        df = self._calculate_smas(df)
        df = self._calculate_aroon(df)
        df = self._calculate_obv(df)

        # 2. Fundamental Screen
        cfg = getattr(config, 'strategy', config)
        pe_max = getattr(cfg, 'pe_ratio_max', 35.0)
        pb_max = getattr(cfg, 'pb_ratio_max', 5.0)
        
        fundamentals = self.get_fundamental_data(ticker)
        is_fundamentally_strong = (
            fundamentals.get('pe_ratio', float('inf')) < pe_max and
            fundamentals.get('pb_ratio', float('inf')) < pb_max
        )

        if not is_fundamentally_strong:
            return pd.Series(0, index=df.index) # Skip if fundamentals are weak

        # 3. Generate Signals based on indicator confluence
        signals = pd.Series(0, index=df.index)

        # Conditions for entry and exit
        df['golden_cross'] = (df['sma_50'].shift(1) < df['sma_200'].shift(1)) & (df['sma_50'] > df['sma_200'])
            fundamentals.get('market_cap', 0) >= mcap_min
        ]
        score_value = sum(crit_hits) / 4.0
        value_ok = score_value >= value_min_fraction

        # ---- Composite scoring components ----
        trend_score = np.clip((df['sma_50'] - df['sma_200']) / df['sma_200'].replace(0, np.nan), -0.1, 0.1) / 0.1
        trend_score = (trend_score + 1) / 2.0  # map -1..1 -> 0..1
        adl_slope = df['adl'].diff(10)
        adl_score = (adl_slope > 0).astype(int) * (
            adl_slope.clip(lower=0) / (adl_slope.clip(lower=0).rolling(100).max() + 1e-9)
        )
        vol_score = (df['Volume'] / (df['vol_ma_50'] + 1e-9)).clip(0, 3) / 3

        base_comp = (
            w_trend * trend_score +
            w_adl * adl_score.fillna(0) +
            w_vol * vol_score.fillna(0)
        )
        composite = base_comp * score_value  # scale by fundamentals fraction (not hard gate)
        df['composite_score'] = composite

        signals = pd.Series(0, index=df.index)
        comp_thr = comp_thr_cfg
        persistent_gc_bars = persistent_days

        # ---- Iterative signal generation ----
        for i in range(1, len(df)):
            golden_event = df['golden'].iloc[i] == 1 and df['golden_shift'].iloc[i] == 0
            strong_volume = df['Volume'].iloc[i] > (df['vol_ma_50'].iloc[i] * vol_confirm_factor)
            rising_vpt = df['vpt'].iloc[i] > df['vpt'].iloc[i - 1]

            # Pseudo golden cross during early baseline formation
            pseudo_golden = False
            if np.isnan(df['trend_baseline'].iloc[i]) and i >= 3:
                rises = (df['sma_50'].iloc[i - 3:i + 1].diff().fillna(0) > 0).sum() >= 3
                pseudo_golden = rises and df['sma_50'].iloc[i] > df['sma_50'].iloc[i - 3]

            if (
                value_ok and (golden_event or pseudo_golden) and strong_volume and rising_vpt and
                df['composite_score'].iloc[i] >= comp_thr
            ):
                signals.iloc[i] = 1
            elif value_ok and df['golden'].iloc[i] == 1 and df['composite_score'].iloc[i] >= (comp_thr - 0.05):
                start = max(0, i - persistent_gc_bars + 1)
                if df['golden'].iloc[start:i + 1].all():
                    signals.iloc[i] = 1

            # Exits
            death_cross = df['golden'].iloc[i] == 0 and df['golden_shift'].iloc[i] == 1
            vol_spike = df['Volume'].iloc[i] > df['vol_ma_50'].iloc[i] * 2.0
            if death_cross or vol_spike:
                signals.iloc[i] = -1

            # Debug snapshot
            if os.getenv('LONGTERM_DEBUG', '').lower() in ('1', 'true', 'yes') and i % 15 == 0:
                try:
                    print(
                        f"[LONGTERM_DEBUG] {ticker} i={i} comp={df['composite_score'].iloc[i]:.3f} "
                        f"value_frac={score_value:.2f} golden={df['golden'].iloc[i]} pseudo={int(pseudo_golden)} "
                        f"vol_mult={(df['Volume'].iloc[i] / (df['vol_ma_50'].iloc[i] + 1e-9)):.2f} strong_vol={int(strong_volume)}"
                    )
                except Exception:
                    pass

            # Diagnostics row
            self._record_diag_row(
                ticker,
                df.index[i],
                {
                    'close': df['Close'].iloc[i],
                    'sma_50': df['sma_50'].iloc[i],
                    'trend_baseline': df['trend_baseline'].iloc[i],
                    'golden': df['golden'].iloc[i],
                    'pseudo_golden': int(pseudo_golden),
                    'value_fraction': score_value,
                    'composite_score': df['composite_score'].iloc[i],
                    'volume': df['Volume'].iloc[i],
                    'vol_ma_50': df['vol_ma_50'].iloc[i],
                    'vol_mult': (df['Volume'].iloc[i] / (df['vol_ma_50'].iloc[i] + 1e-9)),
                    'adl': df['adl'].iloc[i],
                    'adl_ma_50': df['adl_ma_50'].iloc[i],
                    'vpt': df['vpt'].iloc[i],
                    'atr_14': df['atr_14'].iloc[i],
                    'buy_signal': int(signals.iloc[i] == 1),
                    'sell_signal': int(signals.iloc[i] == -1)
                }
            )

        self._last_composite = float(df['composite_score'].iloc[-1]) if len(df) else 0.0
        return signals

    def calculate_position_size(self, data: pd.DataFrame, capital: float, config: Any) -> float:
        """ATR-aware position size (simple placeholder).

        Currently: return min(capital * max_position_size, capital) (no leverage) but compute ATR so we could
        later do: position_dollars = risk_per_trade * capital / (ATR_pct).
        """
        cfg = getattr(config, 'strategy', config)
        max_pos = getattr(cfg, 'max_position_size', 0.15)
        df = next(iter(data.values())) if isinstance(data, dict) else data
        if 'atr_14' in df.columns and len(df['atr_14'].dropna()) > 0 and df['Close'].iloc[-1] > 0:
            atr = df['atr_14'].iloc[-1]
            atr_pct = atr / df['Close'].iloc[-1]
            # Risk-based sizing example (not yet enforcing): risk_cap = capital * cfg.risk_per_trade
            # shares = (risk_cap / (atr * k))  -> convert to dollars later; left as future enhancement.
        return capital * max_pos

    def get_stop_loss(self, data: pd.DataFrame, entry_price: float, position_type: str, config: Any) -> float:
        """Return a 5% static stop pending future ATR / trailing integration."""
        stop_loss_pct = 0.05
        if position_type == 'long':
            return entry_price * (1 - stop_loss_pct)
        return entry_price * (1 + stop_loss_pct)

    def should_rebalance(self, current_date: pd.Timestamp, last_rebalance: Optional[pd.Timestamp], config: Any) -> bool:
        """Check if portfolio should be rebalanced (monthly)"""
        if last_rebalance is None:
            return True
            
        # Rebalance monthly
        return (current_date.year != last_rebalance.year or
                current_date.month != last_rebalance.month)